var store = [{
        "title": "github.io blog start",
        "excerpt":"Github Blog service - github.io blog start test  ","categories": ["Blog"],
        "tags": ["Blog"],
        "url": "http://localhost:4000/blog/first-post/",
        "teaser": null
      },{
        "title": "Frontend - TDD(Test Driven Development)",
        "excerpt":"테스트 코드 작성하시나요? 왜 안하게 되는가요? 힘들고 일정에 치여서…나중에 하자. 나중은 결코 오지 않는다. TDD의 궁극적 목표 Clean Code that works Test First Programming TDD Cycle 왜 어려운가? 코드가 Testable 하지 않다. Testable code를 작성하면 해결된다. Separation of Concerns 각 요소가 자신이 관심이 있는 부분만 해결 Example(To-Do App) Testcode 먼저...","categories": ["frontend","tdd"],
        "tags": ["frontend"],
        "url": "http://localhost:4000/frontend/tdd/Frontend-TDD/",
        "teaser": null
      },{
        "title": "Visualization Study Chapter 1",
        "excerpt":"“What’s Vis, and Why Do It?” Book : Visualization Analysis and Design - Tamara Munzner Chapter 1 1.1 The Big Picture 1.2 Why have a human in the loop? 시각화는 사용자가 정확히 자신이 가진 문제점이 뭔지 모르는 상황에서 데이터 분석시 도움을 준다. 사용자가 가진 문제가 well-defined question 이라면, 통계학이나 머신러닝과...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/Visualization-study-chapter-1/",
        "teaser": null
      },{
        "title": "Brower Rendering",
        "excerpt":"브라우저의 렌더링 과정 (Chapter 38) Parsing 프로그래밍 언어로 작성된 텍스트 파일을 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해하고, 토큰에 문법적 의미와 구조를 반영하여 트리 구조의 자료구조인 parse tree/syntax tree를 생성하는 과정 Rendering html, css, javascript 로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것 브라우저의 렌더링 과정 브라우저는 html,...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/brower-rendering/",
        "teaser": null
      },{
        "title": "Dom Node Search",
        "excerpt":"DOM DOM (Document Object Model) HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메소드를 제공하는 트리 자료구조이다. Node HTML 요소와 노드 객체 HTML 요소란 HTML 문서를 구성하는 개별적인 요소를 의미한다. HTML 요소의 구조 : 콘텐츠&lt;/종료태그&gt; HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/DOM-node-search/",
        "teaser": null
      },{
        "title": "Dom",
        "excerpt":"DOM DOM (Document Object Model) HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메소드를 제공하는 트리 자료구조이다. Node HTML 요소와 노드 객체 HTML 요소란 HTML 문서를 구성하는 개별적인 요소를 의미한다. HTML 요소의 구조 : 콘텐츠&lt;/종료태그&gt; HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/DOM/",
        "teaser": null
      },{
        "title": "Event",
        "excerpt":"Event Event Driven Programming 클릭, 키보드 입력, 마우스 이동 등의 이벤트가 발생하면 브라우저가 이를 감지해 특정 타입의 이벤트를 발생시킨다. Event handler(listener) 이벤트가 발생했을 때 호출될 함수. 브라우저에 호출을 위임한 함수. Event handler 등록 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것 “언제 함수를 호출해야 하는가?” 브라우저는 특정 사건을 감지하여...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/Event/",
        "teaser": null
      },{
        "title": "Asynchronous Programming",
        "excerpt":"Asynchronous Programming Chapter 42 동기 처리와 비동기 처리 함수가 호출되면 함수 코드가 평가되어 함수 실행 컨텍스트가 생성된다. 이 함수 실행 컨텍스트는 실행 컨텍스트 스택(call stack)에 푸시되고 함수 코드가 실행된다. 함수 코드 실행이 종료되면 함수 실행 컨텍스트는 실행 컨텍스트 스택에서 pop되어 제거된다. 실행 컨텍스트 스택에 함수 컨텍스트 스택이 푸시되는 것은 바로...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/Asynchronous-programming/",
        "teaser": null
      },{
        "title": "Socket",
        "excerpt":"Socket 서버와 클라이언트가 데이터를 주고 받을 때 통신할 수 있도록 연결해주는 연결부이다. 하나의 소켓으로는 하나의 클라이언트와만 통신이 가능하다. 하나의 포트를 사용하는 것 같지만, 내부적으로는 클라이언트 수만큼의 포트를 사용한다. 실시간 데이터 전송 방식 polling 주기적으로 클라이언트가 서버로 요청을 보내 변경된 정보가 있는지 확인한다. 서버로부터의 메시지가 일정 간격마다 있을 때 사용할 수...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/Socket/",
        "teaser": null
      },{
        "title": "Ajax",
        "excerpt":"Ajax Ajax Asynchronous javascript and XML javascript 를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식. 브라우저에서 제공하는 Web API 인 XMLHttpRequest 객체를 기반으로 동작한다. 이 객체는 HTTP 비동기 통신을 위한 메소드와 프로퍼티를 제공한다. Ajax 이전의 웹페이지 html 태그로 시작해 html 태그로...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/ajax/",
        "teaser": null
      },{
        "title": "Promise(1)",
        "excerpt":"자바스크립트는 비동기 처리를 위한 하나의 패턴을 콜백 함수를 사용한다. 콜백 함수는 아래와 같은 문제가 있다. 콜백 헬로 인한 가독성 저하 비동기 처리 중 발생한 에러 처리 힘듬 여러 개의 비동기 처리를 한 번에 처리하는 한계 ES6 에서는 비동기 처리를 위한 또 다른 패턴은 Promise를 도입하였다. 비동기 처리를 위한 콜백 패턴의...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/Promise(1)/",
        "teaser": null
      },{
        "title": "Promise(2)",
        "excerpt":"Promise 의 정적 메소드 함수도 객체이므로 메소드를 가질 수 있다. 5가지 정적 메소드를 제공한다. Promise.resolve / Promise.reject 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해서 사용한다. resolve 메소드는 인수로 전달받은 값을 resolve하는 프로미스를 생성한다. reject 메소드는 인수로 전달받은 값을 reject하는 프로미스를 생성한다. const resolvedPromise = Promise.resolve([1, 2, 3]); resolvedPromise.then(console.log); //[1,2,3] const...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/Promise(2)/",
        "teaser": null
      },{
        "title": "Restapi",
        "excerpt":"REST API REST (REpresentational State Transfer) HTTP 를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍쳐 REST API REST 를 기반으로 서비스 API 를 구현한 것 RESTful REST 의 기본 원칙을 성실히 지킨 서비스 디자인 REST API 자원(resource), 행위(verb), 표현(representations)의 3가지 요소로 구성된다. 자원 자원, URI(Endpoint). 행위 자원에 대한 행위,...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/RestAPI/",
        "teaser": null
      },{
        "title": "Errorhandling",
        "excerpt":"에러 처리의 필요성 발생한 에러에 대해 대처하지 않고 방치하면 프로그램이 강제 종료된다. 직접적으로 에러를 발생시키지 않는 exceptional 한 상황이 발생할 수도 있다. const $button = document.querySelector(\"button\"); //에러를 발생시키지 않고, null을 반환한다. $button.classList.add(\"disabled\"); //TypeError : Cannot read property 'classList' of null $button?.classList.add(\"disabled\"); //optional chaining 연산자 사용 try … catch … finally...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/errorHandling/",
        "teaser": null
      },{
        "title": "Async Await",
        "excerpt":"async/await generator를 사용하여 비동기 처리를 동기 처리처럼 동작하도록 구현했지만 코드가 무척 장황하고 가독성이 떨어진다. ES8에서는 비동기 처리를 동기 처리처럼 동작하도록 구현하는 async/await를 도입하였다. async/await 는 promise 를 기반으로 동작한다. 프로미스의 후속 처리 메소드에 콜백 함수를 전달해 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스를 사용할 수 있다....","categories": [],
        "tags": [],
        "url": "http://localhost:4000/async-await/",
        "teaser": null
      },{
        "title": "Generator",
        "excerpt":"Generator ES6에서 도입된 generator는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수이다. 일반 함수와의 차이점 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다. 제너레이터 함수의 정의 function* 키워드로 선언하고,...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/generator/",
        "teaser": null
      },{
        "title": "Babel Webpack",
        "excerpt":"Babel과 Webpack을 이용한 ES6+/ES.NEXT 개발 환경 구축 ES.NEXT (제안 단계에 있는 ES 제안 사양) 대부분의 프로젝트가 모듈을 사용하므로 모듈 로더가 필요하다. ES6 모듈은 대부분의 모던 브라우저에서 가능하지만, 아래와 같은 이유로 별도의 모듈을 사용하는 것이 더 일반적이다. IE를 포함한 구형 브라우저는 ESM 을 지원하지 않는다. ESM (ES6 모듈) 을 사용하더라도 트랜스파일링이나...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/Babel-Webpack/",
        "teaser": null
      },{
        "title": "Module",
        "excerpt":"module application 을 구성하는 개별적 요소로 재사용 가능한 코드 조각 일반적으로 모듈은 기능을 기준으로 파일 단위로 분리한다. 모듈은 자신만의 파일 스코프(모듈 스코프)를 가질 수 있어야 한다. 각 모듈은 모든 자산의 캡슐화되어 있다. 공개가 필요한 자산에 한정해 선택적으로 공개 가능하다 - export 모듈 사용자는 모듈이 export 한 자산 중 일부나 전체를...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/module/",
        "teaser": null
      },{
        "title": "Node",
        "excerpt":"Node.js 는 자바스크립트 런타임 환경으로 주로 서버 사이드 애플리케이션 개발에 사용되는 소프트웨어 플랫폼이다. 브라우저 외부 환경에서 자바스크립트 애플리케이션 개발에 사용되며, 이에 필요한 모듈, 파일 시스템, HTTP 등 Built-in API를 제공한다. 자바스크립트를 사용해 개발하므로, Front-end, back-end 에서 자바스크립트를 사용할 수 있다는 동형성(isomorphic)을 가진다. Non-blocking I/O 지원 DB로부터 대량의 데이터를 가져와 웹...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/node/",
        "teaser": null
      },{
        "title": "Jscourse30",
        "excerpt":"30일 간의 javascript 미니 프로젝트를 수행한다. no framework, no compiler, no library. only vanila javascript만 사용한다. 프로젝트 수행 방식 원하는 방법대로 수행해라. 정답인 코드는 없다. 동영상 시청 후 프로젝트 코드를 작성해도 되고, 프로젝트 코드 먼저 보고 작성한 후에 동영상을 시청해도 된다. 그런데, 동영상에서 모범 답안을 알려주기 때문에 우선 나는 finished...","categories": [],
        "tags": [],
        "url": "http://localhost:4000/jscourse30/",
        "teaser": null
      }]
