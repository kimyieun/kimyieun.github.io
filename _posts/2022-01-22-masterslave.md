---
title: "Master-Slave Design Pattern"

categories:
  - architecturestyle

tags:
  - architecturestyle
---

### Master-Slave Design Pattern
- 아키텍처 패턴보다는 디자인 패턴으로 소개
- 마스터 컴포넌트는 자신과 동등한 역할을 하는 slave 컴포넌트에 작업을 분산하고, slave 컴포넌트들이 반환한 결과로부터 최종 결과를 계산하는 패턴
- 행렬 곱셈, 분산 서비스, 병렬 계산을 위한 프로세스 제어 등
- Context
  - 작업을 의미적으로 동일한 여러 서브태스크로 분할한다.
- Problem
  - 분할 정복 원칙에 따라 독립적으로 처리하는 하위 작업으로 작업 분할
  - 각 프로세스에 의해 제공된 결과에서 전체 결과 산출
- Solution
  - 개별 서브태스크들의 프로세싱 간에 조정 인스턴스 도입(Master)
  - 작업 서비스 대상자(Slave)는 작업이 분할 정복 원칙에 근거한다는 것을 알 필요가 없다.
  - slave 의 작업은 서로 다르지만 의미적으로 동일한 구현 사용 권장
- Master
  - 모든 slave 들에 하나의 동일한 인터페이스 제공
  

### 동작 방식
1. 클라이언트가 마스터에게 서비스를 요청한다.
2. 마스터는 일을 분할하고 slaves 를 호출한다.
3. 모든 slaves 에게 결과를 받으면 combine 한다.
4. 결과를 클라이언트에게 돌려준다.
  

### 설계 순서
1. 작업을 분할한다.
2. 하위 작업의 결과를 조합한다.
3. master 와 slave 간의 협력을 정의한다.
   1. slave 인터페이스 정의 
   2. master 는 이 인터페이스를 사용해 개별 하위 작업 처리를 위임한다.
4. slave 컴포넌트 구현
5. master 컴포넌트 구현
  

### Discussion
- 장점
  - 장애 허용성
    - 서비스 실행을 여러 개의 복재된 구현에 위임. 분할된 서비스들의 실행에 장애가 발생하는지 탐지하고 처리
    - master 자체에 장애가 발생하는 것은 대처 불가
  - 병렬 컴퓨팅
    - 복잡한 태스크를 병렬로 실행되는 동일한 서브태스크들로 분할
    - hw 아키텍처에 강하게 좌우된다.
  - 계산 정확도
    - 서비스 실행을 각기 다른 몇개의 구현들에 위임
    - 정확하지 않은 결과 탐지하고 처리한다.
  - 교환 가능성, 확장성 도입
  - 역할 분리, 효율 향상
- 단점
  - 실행 가능성 떨어짐(feasibility) - 마스터 작업 분할, 할당, 대기, 최종 결과 계산
  - 하드웨어 종속
  - 구현 어려움
  - 이식성 떨어진다(hw 종속되어 다른 hw 로 이동 어려움)
