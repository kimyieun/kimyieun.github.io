---
title : "ES6 함수의 추가 기능"

categories :
    - javascript

tags :
    - javascript

---
  ** 모던 자바스크립트 Deep Dive 책을 읽고 정리한 포스팅이다.

### ES6 함수의 추가 기능
- ES6 이전의 모든 함수는 callable 이면서 constructor 이다.
  - callable : 호출할 수 있는 함수 객체
  - constructor - 인스턴스를 생성할 수 있는 함수 객체

```javascript
var foo = function(){
    return 1;
};

foo(); // 일반 함수로 호출
new foo(); // 생성자 함수로서 호출
var obj = {foo : foo};
obj.foo(); // 메소드로서 호출
```

- ES6 부터는 메서드와 화살표 함수는 non-constructor 이다.
  
#### Method
- ES6 에서 메서드에 대한 정의가 명확하게 규명되었는데, **메서드 축약 표현으로 정의된 함수**만을 의미한다.

```javascript
const obj = {
    x : 1,
    foo() {return this.x; },
    bar : function() {return this.x; }
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1

new obj.foo(); // TypeError : obj.foo is not a constructor
new obj.bar(); // bar {}
```

- 위와 같이 메서드로 정의할 때는 메서드 축약 표현으로 사용하는 것을 권장한다. 

#### Arrow function
- function 키워드 대신 fat arrow 를 사용하여 간략하게 함수를 정의한다. 표현뿐만 아니라 내부 동작도 간략하다.
- 특히, 콜백 함수 내부에서 this 가 전역 객체를 가리키는 문제에 대한 대안으로 적절하다.
- 함수 정의 시 함수 선언문으로 정의할 수 없고, 함수 표현식을 사용해야 한다.
```javascript
const add = (x, y) => x + y;
add(1, 2); // 3
```

- IIFE 로 사용할 수 있다.

```javascript
const person = (name => ({
    sayHi() {return `Hi, I am ${name}.`; }
}))('KIM');
console.log(person.sayHi()); // Hi, I am KIM.
```

### 일반 함수와의 차이
- 콜백 함수로 사용했을 때 표현이 간략해서 유용하다.

1. 화살표 함수는 non-constructor 이다.
2. 중복된 매개변수 이름을 선언할 수 없다.
3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.
    - 화살표 함수 내부에서 이들을 참조하면, 스코프 체인을 통해 상위 스코프의 해당 값을 참조한다. 화살표 함수가 중첩되어 있으면, 화살표 함수가 아닌 가장 가까운 상위 함수에서 참조한다.


### this
- **"콜백 함수 내부의 this 문제"**
  - this 바인딩은 함수 정의가 아닌, 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.
  - 문제가 되는 경우는 **일반 함수로서 호출되는 콜백 함수의 경우**이다.


```javascript
class Prefixer{
    constructor(prefix){
        this.prefix = prefix;
    }

    add(arr){
        // 1
        return arr.map(function(item){
            // 2
            return this.prefix + item;
        });
    }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select'])); // TypeError : Cannot read property 'prefix' of undefined
```

- (1)에서 this 는 메서드를 호출한 객체를 가리킨다. (prefixer 객체)
- (2)에서 this 는 undefined 를 가리킨다. map 메서드가 콜백 함수를 일반 함수로서 호출하기 때문이다. 그러면 일반 함수로서 호출되는 모든 함수 내부의 this 는 전역 객체를 가리키는데 왜 undefined? class 내부 모든 코드에는 strict mode 가 암묵적으로 적용된다.


### ES6 이전의 해결 방법
### ES6 에서의 해결 방법
- 화살표 함수를 사용하여 해결할 수 있다.
- 화살표 함수는 함수 자체의 this 바인딩을 갖지 않기 때문에, 상위 스코프의 this 를 그대로 참조한다. 이를 **lexical this**라 한다.

```javascript
class Prefixer{
    constructor(prefix){
        this.prefix = prefix;
    }

    add(arr){
        // 1
        return arr.map(item => this.prefix + item);
    }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']));  // ['-webkit-transition', '-webkit-user-select'];
```



